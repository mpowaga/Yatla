/* DateTime.c generated by valac 0.24.0, the Vala compiler
 * generated from DateTime.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <time.h>


#define YATLA_TYPE_DATE_TIME (yatla_date_time_get_type ())
#define YATLA_DATE_TIME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_DATE_TIME, YatlaDateTime))
#define YATLA_DATE_TIME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_DATE_TIME, YatlaDateTimeClass))
#define YATLA_IS_DATE_TIME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_DATE_TIME))
#define YATLA_IS_DATE_TIME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_DATE_TIME))
#define YATLA_DATE_TIME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_DATE_TIME, YatlaDateTimeClass))

typedef struct _YatlaDateTime YatlaDateTime;
typedef struct _YatlaDateTimeClass YatlaDateTimeClass;
typedef struct _YatlaDateTimePrivate YatlaDateTimePrivate;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _YatlaDateTime {
	GObject parent_instance;
	YatlaDateTimePrivate * priv;
};

struct _YatlaDateTimeClass {
	GObjectClass parent_class;
};

struct _YatlaDateTimePrivate {
	GDateTime* datetime;
	gboolean _valid;
};


static gpointer yatla_date_time_parent_class = NULL;

GType yatla_date_time_get_type (void) G_GNUC_CONST;
#define YATLA_DATE_TIME_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), YATLA_TYPE_DATE_TIME, YatlaDateTimePrivate))
enum  {
	YATLA_DATE_TIME_DUMMY_PROPERTY
};
#define YATLA_DATE_TIME_DEFAULT_FORMAT "%FT%H:%M:%S%z"
YatlaDateTime* yatla_date_time_new (void);
YatlaDateTime* yatla_date_time_construct (GType object_type);
YatlaDateTime* yatla_date_time_new_from_string_with_format (const gchar* dateStr, const gchar* format);
YatlaDateTime* yatla_date_time_construct_from_string_with_format (GType object_type, const gchar* dateStr, const gchar* format);
gboolean yatla_date_time_parse (YatlaDateTime* self, const gchar* dateStr);
gboolean yatla_date_time_parse_date (YatlaDateTime* self, const gchar* dateStr);
GDateTime* yatla_date_time_get_datetime (YatlaDateTime* self);
static void yatla_date_time_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static GRegex* _tmp_regex_0 = NULL;

YatlaDateTime* yatla_date_time_construct (GType object_type) {
	YatlaDateTime * self = NULL;
	GDateTime* _tmp0_ = NULL;
	self = (YatlaDateTime*) g_object_new (object_type, NULL);
	_tmp0_ = g_date_time_new_now_local ();
	_g_date_time_unref0 (self->priv->datetime);
	self->priv->datetime = _tmp0_;
	return self;
}


YatlaDateTime* yatla_date_time_new (void) {
	return yatla_date_time_construct (YATLA_TYPE_DATE_TIME);
}


YatlaDateTime* yatla_date_time_construct_from_string_with_format (GType object_type, const gchar* dateStr, const gchar* format) {
	YatlaDateTime * self = NULL;
	GDateTime* _tmp0_ = NULL;
	GDateTime* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	GDateTime* _tmp6_ = NULL;
	GDateTime* _tmp7_ = NULL;
	GDateTime* _tmp8_ = NULL;
	g_return_val_if_fail (dateStr != NULL, NULL);
	g_return_val_if_fail (format != NULL, NULL);
	self = (YatlaDateTime*) g_object_new (object_type, NULL);
	_tmp0_ = g_date_time_new_now_local ();
	_g_date_time_unref0 (self->priv->datetime);
	self->priv->datetime = _tmp0_;
	_tmp1_ = self->priv->datetime;
	_tmp2_ = format;
	_tmp3_ = g_date_time_format (_tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp4_);
	_tmp5_ = dateStr;
	yatla_date_time_parse (self, _tmp5_);
	_tmp6_ = self->priv->datetime;
	_tmp7_ = g_date_time_add_years (_tmp6_, 1900);
	_tmp8_ = _tmp7_;
	_g_date_time_unref0 (_tmp8_);
	return self;
}


YatlaDateTime* yatla_date_time_new_from_string_with_format (const gchar* dateStr, const gchar* format) {
	return yatla_date_time_construct_from_string_with_format (YATLA_TYPE_DATE_TIME, dateStr, format);
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == (-1)) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != (-1)) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == (-1)) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


static inline GRegex* _thread_safe_regex_init (GRegex** re, const gchar * pattern, GRegexMatchFlags match_options) {
	if (g_once_init_enter ((volatile gsize*) re)) {
		GRegex* val = g_regex_new (pattern, match_options, 0, NULL);
		g_once_init_leave ((volatile gsize*) re, (gsize) val);
	}
	return *re;
}


static gpointer _g_regex_ref0 (gpointer self) {
	return self ? g_regex_ref (self) : NULL;
}


gboolean yatla_date_time_parse (YatlaDateTime* self, const gchar* dateStr) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dateStr != NULL, FALSE);
	_tmp0_ = dateStr;
	_tmp1_ = string_index_of (_tmp0_, ":", 0);
	if (_tmp1_ > (-1)) {
		gchar** parts = NULL;
		const gchar* _tmp2_ = NULL;
		gchar** _tmp3_ = NULL;
		gchar** _tmp4_ = NULL;
		gint parts_length1 = 0;
		gint _parts_size_ = 0;
		gchar* part = NULL;
		gchar** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar** partsDate = NULL;
		const gchar* _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gchar** _tmp10_ = NULL;
		gint partsDate_length1 = 0;
		gint _partsDate_size_ = 0;
		gchar** parseDateStrArr = NULL;
		gchar** _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		gchar** _tmp12_ = NULL;
		gint parseDateStrArr_length1 = 0;
		gint _parseDateStrArr_size_ = 0;
		gchar* parseDateStr = NULL;
		gchar** _tmp24_ = NULL;
		gint _tmp24__length1 = 0;
		gchar* _tmp25_ = NULL;
		GRegex* r = NULL;
		GRegex* _tmp26_ = NULL;
		gchar** timeParts = NULL;
		GRegex* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		gchar** _tmp29_ = NULL;
		gchar** _tmp30_ = NULL;
		gint timeParts_length1 = 0;
		gint _timeParts_size_ = 0;
		gchar* hour = NULL;
		gchar* _tmp31_ = NULL;
		gchar* minute = NULL;
		gchar* _tmp32_ = NULL;
		gchar* second = NULL;
		gchar* _tmp33_ = NULL;
		const gchar* _tmp53_ = NULL;
		gboolean _tmp54_ = FALSE;
		gboolean _tmp68_ = FALSE;
		_tmp2_ = dateStr;
		_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, ":", 0);
		parts = _tmp4_;
		parts_length1 = _vala_array_length (_tmp3_);
		_parts_size_ = parts_length1;
		_tmp5_ = parts;
		_tmp5__length1 = parts_length1;
		_tmp6_ = _tmp5_[0];
		_tmp7_ = g_strdup (_tmp6_);
		part = _tmp7_;
		_tmp8_ = part;
		_tmp10_ = _tmp9_ = g_strsplit (_tmp8_, " ", 0);
		partsDate = _tmp10_;
		partsDate_length1 = _vala_array_length (_tmp9_);
		_partsDate_size_ = partsDate_length1;
		_tmp11_ = partsDate;
		_tmp11__length1 = partsDate_length1;
		_tmp12_ = g_new0 (gchar*, (_tmp11__length1 - 1) + 1);
		parseDateStrArr = _tmp12_;
		parseDateStrArr_length1 = _tmp11__length1 - 1;
		_parseDateStrArr_size_ = parseDateStrArr_length1;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp13_ = FALSE;
				_tmp13_ = TRUE;
				while (TRUE) {
					gint _tmp15_ = 0;
					gchar** _tmp16_ = NULL;
					gint _tmp16__length1 = 0;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					gint _tmp18_ = 0;
					gchar** _tmp19_ = NULL;
					gint _tmp19__length1 = 0;
					gint _tmp20_ = 0;
					const gchar* _tmp21_ = NULL;
					gchar* _tmp22_ = NULL;
					gchar* _tmp23_ = NULL;
					if (!_tmp13_) {
						gint _tmp14_ = 0;
						_tmp14_ = i;
						i = _tmp14_ + 1;
					}
					_tmp13_ = FALSE;
					_tmp15_ = i;
					_tmp16_ = partsDate;
					_tmp16__length1 = partsDate_length1;
					if (!(_tmp15_ < (_tmp16__length1 - 1))) {
						break;
					}
					_tmp17_ = parseDateStrArr;
					_tmp17__length1 = parseDateStrArr_length1;
					_tmp18_ = i;
					_tmp19_ = partsDate;
					_tmp19__length1 = partsDate_length1;
					_tmp20_ = i;
					_tmp21_ = _tmp19_[_tmp20_];
					_tmp22_ = g_strdup (_tmp21_);
					_g_free0 (_tmp17_[_tmp18_]);
					_tmp17_[_tmp18_] = _tmp22_;
					_tmp23_ = _tmp17_[_tmp18_];
				}
			}
		}
		_tmp24_ = parseDateStrArr;
		_tmp24__length1 = parseDateStrArr_length1;
		_tmp25_ = _vala_g_strjoinv (" ", _tmp24_, _tmp24__length1);
		parseDateStr = _tmp25_;
		_tmp26_ = _g_regex_ref0 (_thread_safe_regex_init (&_tmp_regex_0, "([0-9]{2})\\:([0-9]{2})\\:([0-9\\.]{2,6})", 0));
		r = _tmp26_;
		_tmp27_ = r;
		_tmp28_ = dateStr;
		_tmp30_ = _tmp29_ = g_regex_split (_tmp27_, _tmp28_, 0);
		timeParts = _tmp30_;
		timeParts_length1 = _vala_array_length (_tmp29_);
		_timeParts_size_ = timeParts_length1;
		_tmp31_ = g_strdup ("00");
		hour = _tmp31_;
		_tmp32_ = g_strdup ("00");
		minute = _tmp32_;
		_tmp33_ = g_strdup ("00");
		second = _tmp33_;
		{
			gint i = 0;
			i = 1;
			{
				gboolean _tmp34_ = FALSE;
				_tmp34_ = TRUE;
				while (TRUE) {
					gint _tmp36_ = 0;
					gchar** _tmp37_ = NULL;
					gint _tmp37__length1 = 0;
					gint _tmp38_ = 0;
					if (!_tmp34_) {
						gint _tmp35_ = 0;
						_tmp35_ = i;
						i = _tmp35_ + 1;
					}
					_tmp34_ = FALSE;
					_tmp36_ = i;
					_tmp37_ = timeParts;
					_tmp37__length1 = timeParts_length1;
					if (!(_tmp36_ < (_tmp37__length1 - 1))) {
						break;
					}
					_tmp38_ = i;
					if (_tmp38_ == 1) {
						gchar** _tmp39_ = NULL;
						gint _tmp39__length1 = 0;
						gint _tmp40_ = 0;
						const gchar* _tmp41_ = NULL;
						gchar* _tmp42_ = NULL;
						_tmp39_ = timeParts;
						_tmp39__length1 = timeParts_length1;
						_tmp40_ = i;
						_tmp41_ = _tmp39_[_tmp40_];
						_tmp42_ = g_strdup (_tmp41_);
						_g_free0 (hour);
						hour = _tmp42_;
					} else {
						gint _tmp43_ = 0;
						_tmp43_ = i;
						if (_tmp43_ == 2) {
							gchar** _tmp44_ = NULL;
							gint _tmp44__length1 = 0;
							gint _tmp45_ = 0;
							const gchar* _tmp46_ = NULL;
							gchar* _tmp47_ = NULL;
							_tmp44_ = timeParts;
							_tmp44__length1 = timeParts_length1;
							_tmp45_ = i;
							_tmp46_ = _tmp44_[_tmp45_];
							_tmp47_ = g_strdup (_tmp46_);
							_g_free0 (minute);
							minute = _tmp47_;
						} else {
							gint _tmp48_ = 0;
							_tmp48_ = i;
							if (_tmp48_ == 3) {
								gchar** _tmp49_ = NULL;
								gint _tmp49__length1 = 0;
								gint _tmp50_ = 0;
								const gchar* _tmp51_ = NULL;
								gchar* _tmp52_ = NULL;
								_tmp49_ = timeParts;
								_tmp49__length1 = timeParts_length1;
								_tmp50_ = i;
								_tmp51_ = _tmp49_[_tmp50_];
								_tmp52_ = g_strdup (_tmp51_);
								_g_free0 (second);
								second = _tmp52_;
							}
						}
					}
				}
			}
		}
		_tmp53_ = parseDateStr;
		yatla_date_time_parse_date (self, _tmp53_);
		_tmp54_ = self->priv->_valid;
		if (_tmp54_) {
			GDateTime* _tmp55_ = NULL;
			gint _tmp56_ = 0;
			GDateTime* _tmp57_ = NULL;
			gint _tmp58_ = 0;
			GDateTime* _tmp59_ = NULL;
			gint _tmp60_ = 0;
			const gchar* _tmp61_ = NULL;
			gint _tmp62_ = 0;
			const gchar* _tmp63_ = NULL;
			gint _tmp64_ = 0;
			const gchar* _tmp65_ = NULL;
			gint _tmp66_ = 0;
			GDateTime* _tmp67_ = NULL;
			_tmp55_ = self->priv->datetime;
			_tmp56_ = g_date_time_get_year (_tmp55_);
			_tmp57_ = self->priv->datetime;
			_tmp58_ = g_date_time_get_month (_tmp57_);
			_tmp59_ = self->priv->datetime;
			_tmp60_ = g_date_time_get_day_of_month (_tmp59_);
			_tmp61_ = hour;
			_tmp62_ = atoi (_tmp61_);
			_tmp63_ = minute;
			_tmp64_ = atoi (_tmp63_);
			_tmp65_ = second;
			_tmp66_ = atoi (_tmp65_);
			_tmp67_ = g_date_time_new_local (_tmp56_, _tmp58_, _tmp60_, _tmp62_, _tmp64_, (gdouble) _tmp66_);
			_g_date_time_unref0 (self->priv->datetime);
			self->priv->datetime = _tmp67_;
		}
		_tmp68_ = self->priv->_valid;
		result = _tmp68_;
		_g_free0 (second);
		_g_free0 (minute);
		_g_free0 (hour);
		timeParts = (_vala_array_free (timeParts, timeParts_length1, (GDestroyNotify) g_free), NULL);
		_g_regex_unref0 (r);
		_g_free0 (parseDateStr);
		parseDateStrArr = (_vala_array_free (parseDateStrArr, parseDateStrArr_length1, (GDestroyNotify) g_free), NULL);
		partsDate = (_vala_array_free (partsDate, partsDate_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (part);
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		return result;
	} else {
		const gchar* _tmp69_ = NULL;
		gboolean _tmp70_ = FALSE;
		_tmp69_ = dateStr;
		_tmp70_ = yatla_date_time_parse_date (self, _tmp69_);
		result = _tmp70_;
		return result;
	}
}


gboolean yatla_date_time_parse_date (YatlaDateTime* self, const gchar* dateStr) {
	gboolean result = FALSE;
	GDate parsed_date = {0};
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp22_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (dateStr != NULL, FALSE);
	memset (&parsed_date, 0, sizeof (GDate));
	_tmp0_ = dateStr;
	g_date_set_parse (&parsed_date, _tmp0_);
	_tmp1_ = g_date_valid (&parsed_date);
	if (_tmp1_) {
		struct tm time = {0};
		struct tm _tmp2_ = {0};
		struct tm _tmp3_ = {0};
		gint _tmp4_ = 0;
		struct tm _tmp5_ = {0};
		gint _tmp6_ = 0;
		struct tm _tmp7_ = {0};
		gint _tmp8_ = 0;
		struct tm _tmp9_ = {0};
		gint _tmp10_ = 0;
		struct tm _tmp11_ = {0};
		gint _tmp12_ = 0;
		struct tm _tmp13_ = {0};
		gint _tmp14_ = 0;
		GDateTime* _tmp15_ = NULL;
		gchar* output = NULL;
		gchar* _tmp16_ = NULL;
		gint output_length1 = 0;
		gint _output_size_ = 0;
		gchar* format = NULL;
		gchar* _tmp17_ = NULL;
		gsize success = 0UL;
		gchar* _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		const gchar* _tmp19_ = NULL;
		gsize _tmp20_ = 0UL;
		gsize _tmp21_ = 0UL;
		memset (&time, 0, sizeof (struct tm));
		g_date_to_struct_tm (&parsed_date, &_tmp2_);
		time = _tmp2_;
		_tmp3_ = time;
		_tmp4_ = _tmp3_.tm_year;
		_tmp5_ = time;
		_tmp6_ = _tmp5_.tm_mon;
		_tmp7_ = time;
		_tmp8_ = _tmp7_.tm_mday;
		_tmp9_ = time;
		_tmp10_ = _tmp9_.tm_hour;
		_tmp11_ = time;
		_tmp12_ = _tmp11_.tm_min;
		_tmp13_ = time;
		_tmp14_ = _tmp13_.tm_sec;
		_tmp15_ = g_date_time_new_local (_tmp4_, _tmp6_, _tmp8_, _tmp10_, _tmp12_, (gdouble) _tmp14_);
		_g_date_time_unref0 (self->priv->datetime);
		self->priv->datetime = _tmp15_;
		_tmp16_ = g_new0 (gchar, 100);
		output = _tmp16_;
		output_length1 = 100;
		_output_size_ = output_length1;
		_tmp17_ = g_strdup ("%c");
		format = _tmp17_;
		_tmp18_ = output;
		_tmp18__length1 = output_length1;
		_tmp19_ = format;
		_tmp20_ = g_date_strftime (_tmp18_, _tmp18__length1, _tmp19_, &parsed_date);
		success = _tmp20_;
		_tmp21_ = success;
		if (_tmp21_ == ((gsize) 0)) {
			self->priv->_valid = FALSE;
			g_warning ("DateTime.vala:82: Failed to formart date.");
		} else {
			self->priv->_valid = TRUE;
		}
		_g_free0 (format);
		output = (g_free (output), NULL);
	} else {
		self->priv->_valid = FALSE;
		g_warning ("DateTime.vala:89: Failed to parse date.");
	}
	_tmp22_ = self->priv->_valid;
	result = _tmp22_;
	return result;
}


static gpointer _g_date_time_ref0 (gpointer self) {
	return self ? g_date_time_ref (self) : NULL;
}


GDateTime* yatla_date_time_get_datetime (YatlaDateTime* self) {
	GDateTime* result = NULL;
	GDateTime* _tmp0_ = NULL;
	GDateTime* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->datetime;
	_tmp1_ = _g_date_time_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


static void yatla_date_time_class_init (YatlaDateTimeClass * klass) {
	yatla_date_time_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (YatlaDateTimePrivate));
	G_OBJECT_CLASS (klass)->finalize = yatla_date_time_finalize;
}


static void yatla_date_time_instance_init (YatlaDateTime * self) {
	self->priv = YATLA_DATE_TIME_GET_PRIVATE (self);
	self->priv->_valid = FALSE;
}


static void yatla_date_time_finalize (GObject* obj) {
	YatlaDateTime * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YATLA_TYPE_DATE_TIME, YatlaDateTime);
	_g_date_time_unref0 (self->priv->datetime);
	G_OBJECT_CLASS (yatla_date_time_parent_class)->finalize (obj);
}


GType yatla_date_time_get_type (void) {
	static volatile gsize yatla_date_time_type_id__volatile = 0;
	if (g_once_init_enter (&yatla_date_time_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (YatlaDateTimeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yatla_date_time_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (YatlaDateTime), 0, (GInstanceInitFunc) yatla_date_time_instance_init, NULL };
		GType yatla_date_time_type_id;
		yatla_date_time_type_id = g_type_register_static (G_TYPE_OBJECT, "YatlaDateTime", &g_define_type_info, 0);
		g_once_init_leave (&yatla_date_time_type_id__volatile, yatla_date_time_type_id);
	}
	return yatla_date_time_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



