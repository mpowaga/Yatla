/* Layout.c generated by valac 0.24.0, the Vala compiler
 * generated from Layout.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <granite.h>
#include <gdk/gdk.h>


#define YATLA_TYPE_LAYOUT (yatla_layout_get_type ())
#define YATLA_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_LAYOUT, YatlaLayout))
#define YATLA_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_LAYOUT, YatlaLayoutClass))
#define YATLA_IS_LAYOUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_LAYOUT))
#define YATLA_IS_LAYOUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_LAYOUT))
#define YATLA_LAYOUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_LAYOUT, YatlaLayoutClass))

typedef struct _YatlaLayout YatlaLayout;
typedef struct _YatlaLayoutClass YatlaLayoutClass;
typedef struct _YatlaLayoutPrivate YatlaLayoutPrivate;

#define YATLA_TYPE_DATABASE (yatla_database_get_type ())
#define YATLA_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_DATABASE, YatlaDatabase))
#define YATLA_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_DATABASE, YatlaDatabaseClass))
#define YATLA_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_DATABASE))
#define YATLA_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_DATABASE))
#define YATLA_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_DATABASE, YatlaDatabaseClass))

typedef struct _YatlaDatabase YatlaDatabase;
typedef struct _YatlaDatabaseClass YatlaDatabaseClass;

#define YATLA_TYPE_TASK (yatla_task_get_type ())
#define YATLA_TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_TASK, YatlaTask))
#define YATLA_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_TASK, YatlaTaskClass))
#define YATLA_IS_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_TASK))
#define YATLA_IS_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_TASK))
#define YATLA_TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_TASK, YatlaTaskClass))

typedef struct _YatlaTask YatlaTask;
typedef struct _YatlaTaskClass YatlaTaskClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define YATLA_TYPE_SIDEBAR (yatla_sidebar_get_type ())
#define YATLA_SIDEBAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_SIDEBAR, YatlaSidebar))
#define YATLA_SIDEBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_SIDEBAR, YatlaSidebarClass))
#define YATLA_IS_SIDEBAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_SIDEBAR))
#define YATLA_IS_SIDEBAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_SIDEBAR))
#define YATLA_SIDEBAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_SIDEBAR, YatlaSidebarClass))

typedef struct _YatlaSidebar YatlaSidebar;
typedef struct _YatlaSidebarClass YatlaSidebarClass;
typedef struct _Block4Data Block4Data;
typedef struct _YatlaSidebarPrivate YatlaSidebarPrivate;

#define YATLA_TYPE_LIST (yatla_list_get_type ())
#define YATLA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_LIST, YatlaList))
#define YATLA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_LIST, YatlaListClass))
#define YATLA_IS_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_LIST))
#define YATLA_IS_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_LIST))
#define YATLA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_LIST, YatlaListClass))

typedef struct _YatlaList YatlaList;
typedef struct _YatlaListClass YatlaListClass;
typedef struct _Block5Data Block5Data;
typedef struct _YatlaListPrivate YatlaListPrivate;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

#define YATLA_TYPE_TASK_PREFERENCES (yatla_task_preferences_get_type ())
#define YATLA_TASK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), YATLA_TYPE_TASK_PREFERENCES, YatlaTaskPreferences))
#define YATLA_TASK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), YATLA_TYPE_TASK_PREFERENCES, YatlaTaskPreferencesClass))
#define YATLA_IS_TASK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), YATLA_TYPE_TASK_PREFERENCES))
#define YATLA_IS_TASK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), YATLA_TYPE_TASK_PREFERENCES))
#define YATLA_TASK_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), YATLA_TYPE_TASK_PREFERENCES, YatlaTaskPreferencesClass))

typedef struct _YatlaTaskPreferences YatlaTaskPreferences;
typedef struct _YatlaTaskPreferencesClass YatlaTaskPreferencesClass;
typedef struct _Block6Data Block6Data;

struct _YatlaLayout {
	GtkLayout parent_instance;
	YatlaLayoutPrivate * priv;
	GtkLabel* _list_name;
	GtkBox* _top_box1;
	GtkBox* _top_box2;
	GtkBox* _tasks_box;
	YatlaDatabase* _database;
	gchar* _name;
	GtkEntry* new_task_entry;
	GeeTreeMap* tasks;
};

struct _YatlaLayoutClass {
	GtkLayoutClass parent_class;
};

struct _Block4Data {
	int _ref_count_;
	YatlaLayout* self;
	YatlaSidebar* sidebar;
	gchar* list_name;
};

struct _YatlaSidebar {
	GraniteWidgetsSourceList parent_instance;
	YatlaSidebarPrivate * priv;
	GList* sidebar_list;
};

struct _YatlaSidebarClass {
	GraniteWidgetsSourceListClass parent_class;
};

struct _Block5Data {
	int _ref_count_;
	Block4Data * _data4_;
	gchar* task_note;
};

struct _YatlaList {
	GObject parent_instance;
	YatlaListPrivate * priv;
	GList* tasks;
};

struct _YatlaListClass {
	GObjectClass parent_class;
};

struct _Block6Data {
	int _ref_count_;
	Block4Data * _data4_;
	GtkCheckButton* checkBox;
	YatlaTask* task;
};


static gpointer yatla_layout_parent_class = NULL;

GType yatla_layout_get_type (void) G_GNUC_CONST;
GType yatla_database_get_type (void) G_GNUC_CONST;
GType yatla_task_get_type (void) G_GNUC_CONST;
enum  {
	YATLA_LAYOUT_DUMMY_PROPERTY
};
YatlaLayout* yatla_layout_new (YatlaDatabase* database);
YatlaLayout* yatla_layout_construct (GType object_type, YatlaDatabase* database);
static gint __lambda3_ (YatlaLayout* self, YatlaTask* a, YatlaTask* b);
gint yatla_task_get_id (YatlaTask* self);
static gint ___lambda3__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
GType yatla_sidebar_get_type (void) G_GNUC_CONST;
gboolean yatla_layout_load_layout (YatlaLayout* self, YatlaSidebar* sidebar, const gchar* list_name);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
GType yatla_list_get_type (void) G_GNUC_CONST;
const gchar* yatla_list_get_name (YatlaList* self);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
guint yatla_list_get_size (YatlaList* self);
const gchar* yatla_task_get_name (YatlaTask* self);
const gchar* yatla_task_get_note (YatlaTask* self);
GDateTime* yatla_task_get_date (YatlaTask* self);
gboolean yatla_task_get_is_done (YatlaTask* self);
YatlaTask* yatla_task_new (const gchar* name, const gchar* note, GDateTime* date, gboolean is_done);
YatlaTask* yatla_task_construct (GType object_type, const gchar* name, const gchar* note, GDateTime* date, gboolean is_done);
void yatla_task_set_id (YatlaTask* self, gint value);
static gboolean ___lambda4_ (Block5Data* _data5_, gint x, gint y, gboolean keyboad_tooltip, GtkTooltip* tooltip);
static gboolean ____lambda4__gtk_widget_query_tooltip (GtkWidget* _sender, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip* tooltip, gpointer self);
static void __lambda5_ (Block4Data* _data4_, GtkEntryIconPosition pos, GdkEvent* event);
GType yatla_task_preferences_get_type (void) G_GNUC_CONST;
YatlaTaskPreferences* yatla_task_preferences_new (YatlaLayout* layout, YatlaDatabase* database, YatlaSidebar* sidebar, const gchar* task_name, const gchar* list_name);
YatlaTaskPreferences* yatla_task_preferences_construct (GType object_type, YatlaLayout* layout, YatlaDatabase* database, YatlaSidebar* sidebar, const gchar* task_name, const gchar* list_name);
static void ___lambda5__gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
static void ___lambda11_ (Block6Data* _data6_);
void yatla_task_set_is_done (YatlaTask* self, gboolean value);
static void ____lambda11__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
void yatla_layout_clear_layout (YatlaLayout* self, YatlaDatabase* database, YatlaSidebar* sidebar);
void yatla_sidebar_update_list (YatlaSidebar* self, YatlaTask** tasks, int tasks_length1, const gchar* list_name);
void yatla_layout_reset_layout (YatlaLayout* self, YatlaDatabase* database, YatlaSidebar* sidebar);
void yatla_layout_rename_list (YatlaLayout* self, const gchar* list_name);
static void yatla_layout_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gint __lambda3_ (YatlaLayout* self, YatlaTask* a, YatlaTask* b) {
	gint result = 0;
	YatlaTask* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	YatlaTask* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = b;
	_tmp1_ = yatla_task_get_id (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = a;
	_tmp4_ = yatla_task_get_id (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp2_ > _tmp5_) {
		result = -1;
		return result;
	} else {
		result = 1;
		return result;
	}
}


static gint ___lambda3__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = __lambda3_ ((YatlaLayout*) self, (YatlaTask*) a, (YatlaTask*) b);
	return result;
}


YatlaLayout* yatla_layout_construct (GType object_type, YatlaDatabase* database) {
	YatlaLayout * self = NULL;
	YatlaDatabase* _tmp0_ = NULL;
	YatlaDatabase* _tmp1_ = NULL;
	GeeTreeMap* _tmp2_ = NULL;
	g_return_val_if_fail (database != NULL, NULL);
	self = (YatlaLayout*) g_object_new (object_type, NULL);
	_tmp0_ = database;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->_database);
	self->_database = _tmp1_;
	_tmp2_ = gee_tree_map_new (YATLA_TYPE_TASK, (GBoxedCopyFunc) g_object_ref, g_object_unref, GTK_TYPE_CHECK_BUTTON, (GBoxedCopyFunc) g_object_ref, g_object_unref, ___lambda3__gcompare_data_func, g_object_ref (self), g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->tasks);
	self->tasks = _tmp2_;
	return self;
}


YatlaLayout* yatla_layout_new (YatlaDatabase* database) {
	return yatla_layout_construct (YATLA_TYPE_LAYOUT, database);
}


/**
 * @brief   load layout
 * @details load layout depending on which list
 *          was pressed (depending on list_name)
 * 
 * @param sidebar   : load data from the sidebar_list
 * @param list_name : name of the list, which
 *                       was selected
 * 
 * @return true  : if layout was loaded successfully
 *         false : if layout wasn't loaded successfully
 */
static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		YatlaLayout* self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->sidebar);
		_g_free0 (_data4_->list_name);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		YatlaLayout* self;
		self = _data5_->_data4_->self;
		_g_free0 (_data5_->task_note);
		block4_data_unref (_data5_->_data4_);
		_data5_->_data4_ = NULL;
		g_slice_free (Block5Data, _data5_);
	}
}


static gpointer _g_date_time_ref0 (gpointer self) {
	return self ? g_date_time_ref (self) : NULL;
}


static gboolean ___lambda4_ (Block5Data* _data5_, gint x, gint y, gboolean keyboad_tooltip, GtkTooltip* tooltip) {
	Block4Data* _data4_;
	YatlaLayout* self;
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	_data4_ = _data5_->_data4_;
	self = _data4_->self;
	g_return_val_if_fail (tooltip != NULL, FALSE);
	_tmp0_ = _data5_->task_note;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		result = FALSE;
		return result;
	} else {
		GtkTooltip* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = tooltip;
		_tmp2_ = _data5_->task_note;
		gtk_tooltip_set_text (_tmp1_, _tmp2_);
		result = TRUE;
		return result;
	}
}


static gboolean ____lambda4__gtk_widget_query_tooltip (GtkWidget* _sender, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip* tooltip, gpointer self) {
	gboolean result;
	result = ___lambda4_ (self, x, y, keyboard_tooltip, tooltip);
	return result;
}


static void __lambda5_ (Block4Data* _data4_, GtkEntryIconPosition pos, GdkEvent* event) {
	YatlaLayout* self;
	YatlaTaskPreferences* task_preferences = NULL;
	YatlaDatabase* _tmp0_ = NULL;
	YatlaSidebar* _tmp1_ = NULL;
	GtkEntry* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	YatlaTaskPreferences* _tmp6_ = NULL;
	self = _data4_->self;
	g_return_if_fail (event != NULL);
	_tmp0_ = self->_database;
	_tmp1_ = _data4_->sidebar;
	_tmp2_ = self->new_task_entry;
	_tmp3_ = gtk_entry_get_text (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _data4_->list_name;
	_tmp6_ = yatla_task_preferences_new (self, _tmp0_, _tmp1_, _tmp4_, _tmp5_);
	g_object_ref_sink (_tmp6_);
	task_preferences = _tmp6_;
	gtk_widget_show ((GtkWidget*) task_preferences);
	_g_object_unref0 (task_preferences);
}


static void ___lambda5__gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	__lambda5_ (self, p0, p1);
}


static Block6Data* block6_data_ref (Block6Data* _data6_) {
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void block6_data_unref (void * _userdata_) {
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		YatlaLayout* self;
		self = _data6_->_data4_->self;
		_g_object_unref0 (_data6_->task);
		_g_object_unref0 (_data6_->checkBox);
		block4_data_unref (_data6_->_data4_);
		_data6_->_data4_ = NULL;
		g_slice_free (Block6Data, _data6_);
	}
}


static void ___lambda11_ (Block6Data* _data6_) {
	Block4Data* _data4_;
	YatlaLayout* self;
	GtkCheckButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	_data4_ = _data6_->_data4_;
	self = _data4_->self;
	_tmp0_ = _data6_->checkBox;
	_tmp1_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		YatlaTask* _tmp3_ = NULL;
		_tmp3_ = _data6_->task;
		yatla_task_set_is_done (_tmp3_, TRUE);
	} else {
		YatlaTask* _tmp4_ = NULL;
		_tmp4_ = _data6_->task;
		yatla_task_set_is_done (_tmp4_, FALSE);
	}
}


static void ____lambda11__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	___lambda11_ (self);
}


gboolean yatla_layout_load_layout (YatlaLayout* self, YatlaSidebar* sidebar, const gchar* list_name) {
	gboolean result = FALSE;
	Block4Data* _data4_;
	YatlaSidebar* _tmp0_ = NULL;
	YatlaSidebar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	GtkBox* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	GtkLabel* _tmp8_ = NULL;
	GtkLabel* _tmp9_ = NULL;
	GtkLabel* _tmp10_ = NULL;
	GtkLabel* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	GtkBox* _tmp15_ = NULL;
	GtkLabel* _tmp16_ = NULL;
	GtkBox* _tmp17_ = NULL;
	GtkEntry* _tmp18_ = NULL;
	GtkEntry* _tmp19_ = NULL;
	GtkEntry* _tmp20_ = NULL;
	GtkBox* _tmp21_ = NULL;
	GtkEntry* _tmp22_ = NULL;
	GtkBox* _tmp23_ = NULL;
	gint list_index = 0;
	YatlaSidebar* _tmp24_ = NULL;
	GList* _tmp25_ = NULL;
	gint task_index = 0;
	guint the_longest_task = 0U;
	GtkBox* _tmp122_ = NULL;
	GtkBox* _tmp123_ = NULL;
	GtkBox* _tmp124_ = NULL;
	guint _tmp125_ = 0U;
	GeeTreeMap* _tmp126_ = NULL;
	GeeCollection* _tmp127_ = NULL;
	GeeCollection* _tmp128_ = NULL;
	GeeCollection* _tmp129_ = NULL;
	gint _tmp130_ = 0;
	gint _tmp131_ = 0;
	GtkEntry* _tmp132_ = NULL;
	GeeMapIterator* map_iterator = NULL;
	GeeTreeMap* _tmp133_ = NULL;
	GeeMapIterator* _tmp134_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (sidebar != NULL, FALSE);
	g_return_val_if_fail (list_name != NULL, FALSE);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = sidebar;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data4_->sidebar);
	_data4_->sidebar = _tmp1_;
	_tmp2_ = list_name;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (_data4_->list_name);
	_data4_->list_name = _tmp3_;
	_tmp4_ = _data4_->list_name;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->_name);
	self->_name = _tmp5_;
	_tmp6_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 10);
	g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->_top_box1);
	self->_top_box1 = _tmp6_;
	_tmp7_ = _data4_->list_name;
	_tmp8_ = (GtkLabel*) gtk_label_new (_tmp7_);
	g_object_ref_sink (_tmp8_);
	_g_object_unref0 (self->_list_name);
	self->_list_name = _tmp8_;
	_tmp9_ = self->_list_name;
	gtk_label_set_use_markup (_tmp9_, TRUE);
	_tmp10_ = self->_list_name;
	_tmp11_ = self->_list_name;
	_tmp12_ = gtk_label_get_text (_tmp11_);
	_tmp13_ = g_strdup_printf ("<span font='14'><b>%s</b></span>", _tmp12_);
	_tmp14_ = _tmp13_;
	gtk_label_set_markup (_tmp10_, _tmp14_);
	_g_free0 (_tmp14_);
	_tmp15_ = self->_top_box1;
	_tmp16_ = self->_list_name;
	gtk_box_pack_start (_tmp15_, (GtkWidget*) _tmp16_, TRUE, TRUE, (guint) 0);
	_tmp17_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 10);
	g_object_ref_sink (_tmp17_);
	_g_object_unref0 (self->_top_box2);
	self->_top_box2 = _tmp17_;
	_tmp18_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->new_task_entry);
	self->new_task_entry = _tmp18_;
	_tmp19_ = self->new_task_entry;
	gtk_entry_set_placeholder_text (_tmp19_, "Add new task");
	_tmp20_ = self->new_task_entry;
	gtk_entry_set_icon_from_stock (_tmp20_, GTK_ENTRY_ICON_SECONDARY, "gtk-edit");
	_tmp21_ = self->_top_box2;
	_tmp22_ = self->new_task_entry;
	gtk_box_pack_start (_tmp21_, (GtkWidget*) _tmp22_, TRUE, TRUE, (guint) 0);
	_tmp23_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 10);
	g_object_ref_sink (_tmp23_);
	_g_object_unref0 (self->_tasks_box);
	self->_tasks_box = _tmp23_;
	list_index = 0;
	_tmp24_ = _data4_->sidebar;
	_tmp25_ = _tmp24_->sidebar_list;
	{
		GList* list_collection = NULL;
		GList* list_it = NULL;
		list_collection = _tmp25_;
		for (list_it = list_collection; list_it != NULL; list_it = list_it->next) {
			YatlaList* _tmp26_ = NULL;
			YatlaList* list = NULL;
			_tmp26_ = _g_object_ref0 ((YatlaList*) list_it->data);
			list = _tmp26_;
			{
				YatlaList* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				const gchar* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				gint _tmp31_ = 0;
				_tmp27_ = list;
				_tmp28_ = yatla_list_get_name (_tmp27_);
				_tmp29_ = _tmp28_;
				_tmp30_ = _data4_->list_name;
				if (g_strcmp0 (_tmp29_, _tmp30_) == 0) {
					_g_object_unref0 (list);
					break;
				}
				_tmp31_ = list_index;
				list_index = _tmp31_ + 1;
				_g_object_unref0 (list);
			}
		}
	}
	task_index = 0;
	the_longest_task = (guint) 0;
	while (TRUE) {
		Block5Data* _data5_;
		gint _tmp32_ = 0;
		YatlaSidebar* _tmp33_ = NULL;
		GList* _tmp34_ = NULL;
		gint _tmp35_ = 0;
		gconstpointer _tmp36_ = NULL;
		guint _tmp37_ = 0U;
		guint _tmp38_ = 0U;
		gint task_id = 0;
		YatlaSidebar* _tmp39_ = NULL;
		GList* _tmp40_ = NULL;
		gint _tmp41_ = 0;
		gconstpointer _tmp42_ = NULL;
		GList* _tmp43_ = NULL;
		gint _tmp44_ = 0;
		gconstpointer _tmp45_ = NULL;
		gint _tmp46_ = 0;
		gint _tmp47_ = 0;
		gchar* task_name = NULL;
		YatlaSidebar* _tmp48_ = NULL;
		GList* _tmp49_ = NULL;
		gint _tmp50_ = 0;
		gconstpointer _tmp51_ = NULL;
		GList* _tmp52_ = NULL;
		gint _tmp53_ = 0;
		gconstpointer _tmp54_ = NULL;
		const gchar* _tmp55_ = NULL;
		const gchar* _tmp56_ = NULL;
		gchar* _tmp57_ = NULL;
		YatlaSidebar* _tmp58_ = NULL;
		GList* _tmp59_ = NULL;
		gint _tmp60_ = 0;
		gconstpointer _tmp61_ = NULL;
		GList* _tmp62_ = NULL;
		gint _tmp63_ = 0;
		gconstpointer _tmp64_ = NULL;
		const gchar* _tmp65_ = NULL;
		const gchar* _tmp66_ = NULL;
		gchar* _tmp67_ = NULL;
		GDateTime* task_date = NULL;
		YatlaSidebar* _tmp68_ = NULL;
		GList* _tmp69_ = NULL;
		gint _tmp70_ = 0;
		gconstpointer _tmp71_ = NULL;
		GList* _tmp72_ = NULL;
		gint _tmp73_ = 0;
		gconstpointer _tmp74_ = NULL;
		GDateTime* _tmp75_ = NULL;
		GDateTime* _tmp76_ = NULL;
		gboolean task_is_done = FALSE;
		YatlaSidebar* _tmp87_ = NULL;
		GList* _tmp88_ = NULL;
		gint _tmp89_ = 0;
		gconstpointer _tmp90_ = NULL;
		GList* _tmp91_ = NULL;
		gint _tmp92_ = 0;
		gconstpointer _tmp93_ = NULL;
		gboolean _tmp94_ = FALSE;
		gboolean _tmp95_ = FALSE;
		YatlaTask* task = NULL;
		const gchar* _tmp96_ = NULL;
		const gchar* _tmp97_ = NULL;
		GDateTime* _tmp98_ = NULL;
		gboolean _tmp99_ = FALSE;
		YatlaTask* _tmp100_ = NULL;
		YatlaTask* _tmp101_ = NULL;
		gint _tmp102_ = 0;
		const gchar* _tmp103_ = NULL;
		gint _tmp104_ = 0;
		gint _tmp105_ = 0;
		guint _tmp106_ = 0U;
		GtkCheckButton* checkBox = NULL;
		const gchar* _tmp110_ = NULL;
		GtkCheckButton* _tmp111_ = NULL;
		GtkCheckButton* _tmp112_ = NULL;
		gboolean _tmp113_ = FALSE;
		GtkCheckButton* _tmp114_ = NULL;
		GtkCheckButton* _tmp115_ = NULL;
		GeeTreeMap* _tmp116_ = NULL;
		YatlaTask* _tmp117_ = NULL;
		GtkCheckButton* _tmp118_ = NULL;
		GtkBox* _tmp119_ = NULL;
		GtkCheckButton* _tmp120_ = NULL;
		gint _tmp121_ = 0;
		_data5_ = g_slice_new0 (Block5Data);
		_data5_->_ref_count_ = 1;
		_data5_->_data4_ = block4_data_ref (_data4_);
		_tmp32_ = task_index;
		_tmp33_ = _data4_->sidebar;
		_tmp34_ = _tmp33_->sidebar_list;
		_tmp35_ = list_index;
		_tmp36_ = g_list_nth_data (_tmp34_, (guint) _tmp35_);
		_tmp37_ = yatla_list_get_size ((YatlaList*) _tmp36_);
		_tmp38_ = _tmp37_;
		if (!(((guint) _tmp32_) != _tmp38_)) {
			block5_data_unref (_data5_);
			_data5_ = NULL;
			break;
		}
		_tmp39_ = _data4_->sidebar;
		_tmp40_ = _tmp39_->sidebar_list;
		_tmp41_ = list_index;
		_tmp42_ = g_list_nth_data (_tmp40_, (guint) _tmp41_);
		_tmp43_ = ((YatlaList*) _tmp42_)->tasks;
		_tmp44_ = task_index;
		_tmp45_ = g_list_nth_data (_tmp43_, (guint) _tmp44_);
		_tmp46_ = yatla_task_get_id ((YatlaTask*) _tmp45_);
		_tmp47_ = _tmp46_;
		task_id = _tmp47_;
		_tmp48_ = _data4_->sidebar;
		_tmp49_ = _tmp48_->sidebar_list;
		_tmp50_ = list_index;
		_tmp51_ = g_list_nth_data (_tmp49_, (guint) _tmp50_);
		_tmp52_ = ((YatlaList*) _tmp51_)->tasks;
		_tmp53_ = task_index;
		_tmp54_ = g_list_nth_data (_tmp52_, (guint) _tmp53_);
		_tmp55_ = yatla_task_get_name ((YatlaTask*) _tmp54_);
		_tmp56_ = _tmp55_;
		_tmp57_ = g_strdup (_tmp56_);
		task_name = _tmp57_;
		_tmp58_ = _data4_->sidebar;
		_tmp59_ = _tmp58_->sidebar_list;
		_tmp60_ = list_index;
		_tmp61_ = g_list_nth_data (_tmp59_, (guint) _tmp60_);
		_tmp62_ = ((YatlaList*) _tmp61_)->tasks;
		_tmp63_ = task_index;
		_tmp64_ = g_list_nth_data (_tmp62_, (guint) _tmp63_);
		_tmp65_ = yatla_task_get_note ((YatlaTask*) _tmp64_);
		_tmp66_ = _tmp65_;
		_tmp67_ = g_strdup (_tmp66_);
		_data5_->task_note = _tmp67_;
		_tmp68_ = _data4_->sidebar;
		_tmp69_ = _tmp68_->sidebar_list;
		_tmp70_ = list_index;
		_tmp71_ = g_list_nth_data (_tmp69_, (guint) _tmp70_);
		_tmp72_ = ((YatlaList*) _tmp71_)->tasks;
		_tmp73_ = task_index;
		_tmp74_ = g_list_nth_data (_tmp72_, (guint) _tmp73_);
		_tmp75_ = yatla_task_get_date ((YatlaTask*) _tmp74_);
		_tmp76_ = _tmp75_;
		if (_tmp76_ != NULL) {
			YatlaSidebar* _tmp77_ = NULL;
			GList* _tmp78_ = NULL;
			gint _tmp79_ = 0;
			gconstpointer _tmp80_ = NULL;
			GList* _tmp81_ = NULL;
			gint _tmp82_ = 0;
			gconstpointer _tmp83_ = NULL;
			GDateTime* _tmp84_ = NULL;
			GDateTime* _tmp85_ = NULL;
			GDateTime* _tmp86_ = NULL;
			_tmp77_ = _data4_->sidebar;
			_tmp78_ = _tmp77_->sidebar_list;
			_tmp79_ = list_index;
			_tmp80_ = g_list_nth_data (_tmp78_, (guint) _tmp79_);
			_tmp81_ = ((YatlaList*) _tmp80_)->tasks;
			_tmp82_ = task_index;
			_tmp83_ = g_list_nth_data (_tmp81_, (guint) _tmp82_);
			_tmp84_ = yatla_task_get_date ((YatlaTask*) _tmp83_);
			_tmp85_ = _tmp84_;
			_tmp86_ = _g_date_time_ref0 (_tmp85_);
			_g_date_time_unref0 (task_date);
			task_date = _tmp86_;
		} else {
			_g_date_time_unref0 (task_date);
			task_date = NULL;
		}
		_tmp87_ = _data4_->sidebar;
		_tmp88_ = _tmp87_->sidebar_list;
		_tmp89_ = list_index;
		_tmp90_ = g_list_nth_data (_tmp88_, (guint) _tmp89_);
		_tmp91_ = ((YatlaList*) _tmp90_)->tasks;
		_tmp92_ = task_index;
		_tmp93_ = g_list_nth_data (_tmp91_, (guint) _tmp92_);
		_tmp94_ = yatla_task_get_is_done ((YatlaTask*) _tmp93_);
		_tmp95_ = _tmp94_;
		task_is_done = _tmp95_;
		_tmp96_ = task_name;
		_tmp97_ = _data5_->task_note;
		_tmp98_ = task_date;
		_tmp99_ = task_is_done;
		_tmp100_ = yatla_task_new (_tmp96_, _tmp97_, _tmp98_, _tmp99_);
		task = _tmp100_;
		_tmp101_ = task;
		_tmp102_ = task_id;
		yatla_task_set_id (_tmp101_, _tmp102_);
		_tmp103_ = task_name;
		_tmp104_ = strlen (_tmp103_);
		_tmp105_ = _tmp104_;
		_tmp106_ = the_longest_task;
		if (((guint) _tmp105_) > _tmp106_) {
			const gchar* _tmp107_ = NULL;
			gint _tmp108_ = 0;
			gint _tmp109_ = 0;
			_tmp107_ = task_name;
			_tmp108_ = strlen (_tmp107_);
			_tmp109_ = _tmp108_;
			the_longest_task = (guint) _tmp109_;
		}
		_tmp110_ = task_name;
		_tmp111_ = (GtkCheckButton*) gtk_check_button_new_with_label (_tmp110_);
		g_object_ref_sink (_tmp111_);
		checkBox = _tmp111_;
		_tmp112_ = checkBox;
		_tmp113_ = task_is_done;
		gtk_toggle_button_set_active ((GtkToggleButton*) _tmp112_, _tmp113_);
		_tmp114_ = checkBox;
		gtk_widget_set_has_tooltip ((GtkWidget*) _tmp114_, TRUE);
		_tmp115_ = checkBox;
		g_signal_connect_data ((GtkWidget*) _tmp115_, "query-tooltip", (GCallback) ____lambda4__gtk_widget_query_tooltip, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
		_tmp116_ = self->tasks;
		_tmp117_ = task;
		_tmp118_ = checkBox;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp116_, _tmp117_, _tmp118_);
		_tmp119_ = self->_tasks_box;
		_tmp120_ = checkBox;
		gtk_box_pack_start (_tmp119_, (GtkWidget*) _tmp120_, TRUE, TRUE, (guint) 0);
		_tmp121_ = task_index;
		task_index = _tmp121_ + 1;
		_g_object_unref0 (checkBox);
		_g_object_unref0 (task);
		_g_date_time_unref0 (task_date);
		_g_free0 (task_name);
		block5_data_unref (_data5_);
		_data5_ = NULL;
	}
	_tmp122_ = self->_top_box1;
	gtk_layout_put ((GtkLayout*) self, (GtkWidget*) _tmp122_, 25, 20);
	_tmp123_ = self->_top_box2;
	gtk_layout_put ((GtkLayout*) self, (GtkWidget*) _tmp123_, 20, 40);
	_tmp124_ = self->_tasks_box;
	gtk_layout_put ((GtkLayout*) self, (GtkWidget*) _tmp124_, 20, 100);
	_tmp125_ = the_longest_task;
	g_object_set ((GtkLayout*) self, "width", 65 + (_tmp125_ * 7), NULL);
	_tmp126_ = self->tasks;
	_tmp127_ = gee_abstract_map_get_values ((GeeMap*) _tmp126_);
	_tmp128_ = _tmp127_;
	_tmp129_ = _tmp128_;
	_tmp130_ = gee_collection_get_size (_tmp129_);
	_tmp131_ = _tmp130_;
	g_object_set ((GtkLayout*) self, "height", (guint) (100 + (_tmp131_ * 30)), NULL);
	_g_object_unref0 (_tmp129_);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp132_ = self->new_task_entry;
	g_signal_connect_data (_tmp132_, "icon-press", (GCallback) ___lambda5__gtk_entry_icon_press, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	_tmp133_ = self->tasks;
	_tmp134_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp133_);
	map_iterator = _tmp134_;
	while (TRUE) {
		Block6Data* _data6_;
		GeeMapIterator* _tmp135_ = NULL;
		gboolean _tmp136_ = FALSE;
		GeeMapIterator* _tmp137_ = NULL;
		gpointer _tmp138_ = NULL;
		GeeMapIterator* _tmp139_ = NULL;
		gpointer _tmp140_ = NULL;
		GtkCheckButton* _tmp141_ = NULL;
		_data6_ = g_slice_new0 (Block6Data);
		_data6_->_ref_count_ = 1;
		_data6_->_data4_ = block4_data_ref (_data4_);
		_tmp135_ = map_iterator;
		_tmp136_ = gee_map_iterator_next (_tmp135_);
		if (!_tmp136_) {
			block6_data_unref (_data6_);
			_data6_ = NULL;
			break;
		}
		_tmp137_ = map_iterator;
		_tmp138_ = gee_map_iterator_get_value (_tmp137_);
		_data6_->checkBox = (GtkCheckButton*) _tmp138_;
		_tmp139_ = map_iterator;
		_tmp140_ = gee_map_iterator_get_key (_tmp139_);
		_data6_->task = (YatlaTask*) _tmp140_;
		_tmp141_ = _data6_->checkBox;
		g_signal_connect_data ((GObject*) _tmp141_, "notify::active", (GCallback) ____lambda11__g_object_notify, block6_data_ref (_data6_), (GClosureNotify) block6_data_unref, 0);
		block6_data_unref (_data6_);
		_data6_ = NULL;
	}
	result = TRUE;
	_g_object_unref0 (map_iterator);
	block4_data_unref (_data4_);
	_data4_ = NULL;
	return result;
}


/**
 * @brief   clear the layout
 * @details save the data, which was changed,
 *          then clear the layout
 * 
 * @param database : database, where the data will be saved
 */
void yatla_layout_clear_layout (YatlaLayout* self, YatlaDatabase* database, YatlaSidebar* sidebar) {
	const gchar* _tmp0_ = NULL;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_ = FALSE;
	GtkBox* _tmp12_ = NULL;
	GeeTreeMap* _tmp18_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (database != NULL);
	g_return_if_fail (sidebar != NULL);
	_tmp0_ = self->_name;
	if (_tmp0_ != NULL) {
		YatlaSidebar* _tmp1_ = NULL;
		GeeTreeMap* _tmp2_ = NULL;
		GeeSet* _tmp3_ = NULL;
		GeeSet* _tmp4_ = NULL;
		GeeSet* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		gpointer* _tmp7_ = NULL;
		YatlaTask** _tmp8_ = NULL;
		gint _tmp8__length1 = 0;
		const gchar* _tmp9_ = NULL;
		_tmp1_ = sidebar;
		_tmp2_ = self->tasks;
		_tmp3_ = gee_abstract_map_get_keys ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		_tmp7_ = gee_collection_to_array ((GeeCollection*) _tmp5_, &_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp8__length1 = _tmp6_;
		_tmp9_ = self->_name;
		yatla_sidebar_update_list (_tmp1_, _tmp8_, _tmp6_, _tmp9_);
		_tmp8_ = (_vala_array_free (_tmp8_, _tmp8__length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (_tmp5_);
	}
	_tmp12_ = self->_top_box1;
	if (_tmp12_ != NULL) {
		GtkBox* _tmp13_ = NULL;
		_tmp13_ = self->_top_box2;
		_tmp11_ = _tmp13_ != NULL;
	} else {
		_tmp11_ = FALSE;
	}
	if (_tmp11_) {
		GtkBox* _tmp14_ = NULL;
		_tmp14_ = self->_tasks_box;
		_tmp10_ = _tmp14_ != NULL;
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		GtkBox* _tmp15_ = NULL;
		GtkBox* _tmp16_ = NULL;
		GtkBox* _tmp17_ = NULL;
		_tmp15_ = self->_top_box1;
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp15_);
		_tmp16_ = self->_top_box2;
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp16_);
		_tmp17_ = self->_tasks_box;
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp17_);
	}
	_tmp18_ = self->tasks;
	if (_tmp18_ != NULL) {
		GeeTreeMap* _tmp19_ = NULL;
		_tmp19_ = self->tasks;
		gee_abstract_map_clear ((GeeAbstractMap*) _tmp19_);
	}
}


void yatla_layout_reset_layout (YatlaLayout* self, YatlaDatabase* database, YatlaSidebar* sidebar) {
	YatlaDatabase* _tmp0_ = NULL;
	YatlaSidebar* _tmp1_ = NULL;
	YatlaSidebar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (database != NULL);
	g_return_if_fail (sidebar != NULL);
	_tmp0_ = database;
	_tmp1_ = sidebar;
	yatla_layout_clear_layout (self, _tmp0_, _tmp1_);
	_tmp2_ = sidebar;
	_tmp3_ = self->_name;
	yatla_layout_load_layout (self, _tmp2_, _tmp3_);
}


/**
 * @brief   rename the list
 * @details rename the list, in case it was
 *          renamed in the sidebar
 * 
 * @param list_name : new name for the list_name.label
 */
void yatla_layout_rename_list (YatlaLayout* self, const gchar* list_name) {
	GtkLabel* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkLabel* _tmp2_ = NULL;
	GtkLabel* _tmp3_ = NULL;
	GtkLabel* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (list_name != NULL);
	_tmp0_ = self->_list_name;
	_tmp1_ = list_name;
	gtk_label_set_label (_tmp0_, _tmp1_);
	_tmp2_ = self->_list_name;
	gtk_label_set_use_markup (_tmp2_, TRUE);
	_tmp3_ = self->_list_name;
	_tmp4_ = self->_list_name;
	_tmp5_ = gtk_label_get_text (_tmp4_);
	_tmp6_ = g_strdup_printf ("<span font='14'><b>%s</b></span>", _tmp5_);
	_tmp7_ = _tmp6_;
	gtk_label_set_markup (_tmp3_, _tmp7_);
	_g_free0 (_tmp7_);
}


static void yatla_layout_class_init (YatlaLayoutClass * klass) {
	yatla_layout_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = yatla_layout_finalize;
}


static void yatla_layout_instance_init (YatlaLayout * self) {
}


static void yatla_layout_finalize (GObject* obj) {
	YatlaLayout * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, YATLA_TYPE_LAYOUT, YatlaLayout);
	_g_object_unref0 (self->_list_name);
	_g_object_unref0 (self->_top_box1);
	_g_object_unref0 (self->_top_box2);
	_g_object_unref0 (self->_tasks_box);
	_g_object_unref0 (self->_database);
	_g_free0 (self->_name);
	_g_object_unref0 (self->new_task_entry);
	_g_object_unref0 (self->tasks);
	G_OBJECT_CLASS (yatla_layout_parent_class)->finalize (obj);
}


GType yatla_layout_get_type (void) {
	static volatile gsize yatla_layout_type_id__volatile = 0;
	if (g_once_init_enter (&yatla_layout_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (YatlaLayoutClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) yatla_layout_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (YatlaLayout), 0, (GInstanceInitFunc) yatla_layout_instance_init, NULL };
		GType yatla_layout_type_id;
		yatla_layout_type_id = g_type_register_static (GTK_TYPE_LAYOUT, "YatlaLayout", &g_define_type_info, 0);
		g_once_init_leave (&yatla_layout_type_id__volatile, yatla_layout_type_id);
	}
	return yatla_layout_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



